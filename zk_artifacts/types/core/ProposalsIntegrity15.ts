/* Autogenerated file. Do not edit manually. */
// @ts-nocheck
/* tslint:disable */
/* eslint-disable */

import {
  CircuitZKit,
  CircuitZKitConfig,
  Groth16Proof,
  PlonkProof,
  NumberLike,
  NumericString,
  PublicSignals,
  Groth16Implementer,
  PlonkImplementer,
} from "@solarity/zkit";

import { normalizePublicSignals, denormalizePublicSignals } from "../helpers";

export type PrivateProposalsIntegrity15Groth16 = {
  commitments: NumberLike[];
  permutedProposals: NumberLike[];
  permutationCommitment: NumberLike;
  numActive: NumberLike;
  permutation: NumberLike[];
  randomnesses: NumberLike[];
  permutationRandomness: NumberLike;
};

export type PublicProposalsIntegrity15Groth16 = {
  commitments: NumberLike[];
  permutedProposals: NumberLike[];
  permutationCommitment: NumberLike;
  numActive: NumberLike;
};

export type ProofProposalsIntegrity15Groth16 = {
  proof: Groth16Proof;
  publicSignals: PublicProposalsIntegrity15Groth16;
};

export type CalldataProposalsIntegrity15Groth16 = [
  [NumericString, NumericString],
  [[NumericString, NumericString], [NumericString, NumericString]],
  [NumericString, NumericString],
  [
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
    NumericString,
  ],
];

export class ProposalsIntegrity15 extends CircuitZKit<"groth16"> {
  constructor(config: CircuitZKitConfig) {
    super(config, new Groth16Implementer());
  }

  public async generateProof(
    inputs: PrivateProposalsIntegrity15Groth16,
  ): Promise<ProofProposalsIntegrity15Groth16> {
    const proof = await super.generateProof(inputs as any);

    return {
      proof: proof.proof,
      publicSignals: this._normalizePublicSignals(proof.publicSignals),
    };
  }

  public async calculateWitness(
    inputs: PrivateProposalsIntegrity15Groth16,
  ): Promise<bigint[]> {
    return super.calculateWitness(inputs as any);
  }

  public async verifyProof(
    proof: ProofProposalsIntegrity15Groth16,
  ): Promise<boolean> {
    return super.verifyProof({
      proof: proof.proof,
      publicSignals: this._denormalizePublicSignals(proof.publicSignals),
    });
  }

  public async generateCalldata(
    proof: ProofProposalsIntegrity15Groth16,
  ): Promise<CalldataProposalsIntegrity15Groth16> {
    return super.generateCalldata({
      proof: proof.proof,
      publicSignals: this._denormalizePublicSignals(proof.publicSignals),
    });
  }

  public getSignalNames(): string[] {
    return [
      "commitments",
      "permutedProposals",
      "permutationCommitment",
      "numActive",
    ];
  }

  public getSignalDimensions(name: string): number[] {
    switch (name) {
      case "commitments":
        return [15];
      case "permutedProposals":
        return [15];
      case "permutationCommitment":
        return [];
      case "numActive":
        return [];
      default:
        throw new Error(`Unknown signal name: ${name}`);
    }
  }

  private _normalizePublicSignals(
    publicSignals: PublicSignals,
  ): PublicProposalsIntegrity15Groth16 {
    return normalizePublicSignals(
      publicSignals,
      this.getSignalNames(),
      this.getSignalDimensions,
    );
  }

  private _denormalizePublicSignals(
    publicSignals: PublicProposalsIntegrity15Groth16,
  ): PublicSignals {
    return denormalizePublicSignals(publicSignals, this.getSignalNames());
  }
}

export default ProposalsIntegrity15;
